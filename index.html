<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
  <title> Multiple light dual paraboloid map</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      color: #ffffff;
      font-family: Monospace;                                        
      font-size: 13px;
      text-align: center;
      font-weight: bold;
      background-color: #000000;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 0px;
      width: 100%;
      padding: 5px;
    }

    a {
      color: #ffffff;
    }
  </style>
	</head>
  <body>

    <div id="container"></div>
    <div id="info"> MLDP demo </div>

    <script id="csm_dp_shader_vs" type="x-shader/x-vertex">
      out vec3 bv;
      out vec2 bt;
      out vec3 bn;
      void main()
      {
        bt = uv;
        vec4 hv = modelMatrix * vec4( position, 1.0 );
        bv = hv.xyz/hv.w;
        bn = mat3(modelMatrix) * normal.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="csm_dp_shader_fs" type="x-shader/x-fragment">
      #define PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06

      in vec2 bt;
      in vec3 bv;
      in vec3 bn;

      uniform vec3 l;
      uniform vec3 eye;
      uniform float zNear;
      uniform float zFar;
      uniform float lightsize;
      uniform sampler2D tex0;
      uniform sampler2D dpmap[2 * (M +1)];
      uniform mat4 lightmv;
      uniform float shadow_a;
      uniform float shadow_b;

      vec4 getweights(float alpha, float k, float m)
      {
        vec4 weights = vec4(exp(-alpha*(k) *(k) / (m*m)),
        exp(-alpha*(k +1.0) *(k +1.0) / (m*m)),
        exp(-alpha*(k +2.0) *(k +2.0) / (m*m)),
        exp(-alpha*(k +3.0) *(k +3.0) / (m*m)));
        return weights;
      }

      float estimateFilterWidth(float lightsize, float currentDepth, float blockerDepth)
      {
        // receiver depth
        float receiver = currentDepth;
        float FilterWidth = (receiver -blockerDepth) *lightsize / (2.0 * currentDepth*blockerDepth);
        return FilterWidth;
      }

      float estimatefwo(float lightsize, float distance, float smpos)
      {
        float aa, bb, cc;
        aa = lightsize / distance;
        bb = lightsize / smpos;

        aa = clamp(aa, 0.0, 1.0);
        bb = clamp(bb, 0.0, 1.0);
        cc = aa*bb +sqrt( max((1.0 -aa*aa) *(1.0 -bb*bb),0.0));

        return sqrt(1.0-cc*cc) / (1.0+cc);  // DP map filter size
      }

      float fscm2dp(float ws)
      {
        return ws;
        ws = clamp(ws, 0.0, 2.0);
        if (ws < 1.0)
        {
          ws /= sqrt(ws*ws+1.0) +1.0;
        }
        else
        {
          ws = 2.0 -ws;
          ws = sqrt(ws*ws+1.0) -ws;
        }
        return ws;
      }

      float ufunc( float zval, float fs )
      {
      vec2 p = vec2(sqrt(1.0-zval*zval), abs(zval));
      vec2 t = vec2(2.0*fs , 1.0-fs*fs)/(1.0+fs*fs);
      return max(p.x/(1.0+p.y)
      - (p.x*t.y-p.y*t.x)/(1.0+dot(p,t)), fs);
      }

      vec4 _f4mipmapDPMAP(sampler2D frontface, sampler2D backface, vec3 uv, float fs)
      {
        fs = fscm2dp(fs);
        uv = normalize(uv);

        fs=.74*ufunc(uv.z, fs);

        float W0 = float(textureSize(frontface, 0).x);
        float ml = log(W0*fs) / log(2.0);
        vec2 tc = vec2(uv.x, uv.y) / (1.0 +uv.z);
        vec2 coordf = vec2(-tc.x, tc.y) *.5+.5;
        vec4 cfront= textureLod(frontface, coordf.xy, ml);
        tc = uv.xy / (1.0 -uv.z);
        vec2 coordb = tc*.5 +.5;
        vec4 cback = textureLod(backface, coordb.xy, ml);

        //seams
       // return uv.z < 0.0 ? cback : cfront;

        // delete seams
        float resolution = 1.0 / fs;
        float sss = clamp((length(uv.xy)/(1.0 +abs(uv.z))-1.0)*resolution+1.0, 0.0, 1.0) * .5;
        if(uv.z < 0.0)
        sss = 1.0 -sss;
        return mix(cfront, cback, sss);
      }

      vec4 f4mipmapDPMAP(sampler2D frontface, sampler2D backface, vec3 uv, float fs)
      {
        return _f4mipmapDPMAP(frontface, backface, uv, fs) *2.0-1.0;
      }

      float CSSM_Z_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth
      ){
        vec4 tmp, sin_val_z, cos_val_z;
        float sum0, sum1;
        float depthvalue = f4mipmapDPMAP(dpmap[0], dpmap[1], uv, filterwidth).x;
        sin_val_z = f4mipmapDPMAP(dpmap[5], dpmap[5+M], uv, filterwidth);
        cos_val_z = f4mipmapDPMAP(dpmap[4], dpmap[4+M], uv, filterwidth);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(sin(tmp*(currentDepth-fCSMBias)) / tmp, cos_val_z*weights);
        sum1 = dot(cos(tmp*(currentDepth-fCSMBias)) / tmp, sin_val_z*weights);
        return 0.5*depthvalue +2.0*(sum0 -sum1);
      }

      float CSSM_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        float supress_flag
      ){
        vec4 tmp, sin_val, cos_val;
        float sum0, sum1;

        sin_val = f4mipmapDPMAP(dpmap[3], dpmap[3 +M], uv, filterwidth);
        cos_val = f4mipmapDPMAP(dpmap[2], dpmap[2 +M], uv, filterwidth);

        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));

        sum0 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val*weights);
        sum1 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val*weights);

        float rec = 0.5 +2.0*(sum0 - sum1);
        if(supress_flag == 1.0)
        rec = SCALEFACTOR*(rec -OFFSET);
        return clamp((1.0*rec), 0.0, 1.0);
      }

      float FindBlockDepth(
        vec3 uv,
        float currentDepth,
        float distance,
        float lightsize,
        float zNear,
        float zFar
      ){
        float fs = estimatefwo(lightsize, distance, zNear);
        fs = clamp(fs, 0.0, 2.0);
        float blockedNum = 1.0 - CSSM_Basis(uv, currentDepth, fs, 0.0);
        if( blockedNum>0.001 )
        {
          float Z_avg;
          Z_avg = CSSM_Z_Basis(uv, currentDepth, fs) / blockedNum;
          return Z_avg*zFar;
        }
        else
          return distance+1.0;
      }

      float csm_pcf_filter(
        vec3 uv,
        float currentDepth,
        float filterWidth
      ){
        float shadow = CSSM_Basis(uv, currentDepth, filterWidth, 1.0);
        return shadow;
      }

      float CSM_SoftShadow(
        vec3 uv,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        float shadow_a,
        float shadow_b
      ){
        float currentDepth = distance/zFar;
        float blockerdepth = FindBlockDepth(uv, currentDepth, distance, lightsize, zNear, zFar);
        float shadow = 1.0;
        if( blockerdepth < distance )
        {
          float FilterWidth = estimatefwo(lightsize, distance, blockerdepth);
          shadow = csm_pcf_filter(uv, currentDepth, FilterWidth);
          float temp = shadow_b*(blockerdepth - distance);
          float power = 1.0 +shadow_a* exp(temp);
          shadow = pow(shadow, power );
        }
        return shadow;
      }

      void main()
      {
        gl_FragColor = vec4(1.0); //texture(tex0, bt);
        float specular, diffuse, attenuation;
        float ld;
        vec3 ldir;
        {
          vec3 lpos, edir, ndir;
          ndir = normalize(bn);
          lpos = l-bv;
          ld = length(lpos);
          ldir = lpos/ld;
          edir = normalize( reflect( -(eye-bv), ndir) );  // normalize(  (eye-bv) - 2.0*dot( (eye-bv) ,ndir)* ndir);
          diffuse  = max(dot(ldir, ndir), 0.0);
          specular = pow(max(dot(ldir,edir),0.0), 8.0*mix( 4.0, 1.0, lightsize/.2 )   );
          attenuation = 1.5 / (1.0 + mix( .5, .75, lightsize/.2 ) * ld*ld );
        }

        float vb = CSM_SoftShadow(  -ldir*mat3(lightmv), ld, lightsize, zNear, zFar, shadow_a, shadow_b);

        // gl_FragColor.xyz = vec3(attenuation*( mix(diffuse,specular,.25) ) * vb);
        gl_FragColor.xyz = vec3(diffuse* vb);

        //gl_FragColor = (textureLod( dpmap[1], bt, 5.0 ) + texture( dpmap[5], bt ))/2.0;
        gl_FragColor.xyz = vec3(attenuation*diffuse* vb);


         //vec3 uv = -ldir*mat3(lightmv);
         //vec2 tc = vec2(uv.x, uv.y) / (1.0 +uv.z);
         //tc = vec2(-tc.x, tc.y) *.5+.5;
         //vec4 vb0 = texture(dpmap[0], tc);
         //gl_FragColor.xyz  =  uv;
         //gl_FragColor.xyz  = ldir;//vb0;


        gl_FragColor.w = 1.0;
      }
    </script>
    <script id="csm_cm_shader_vs" type="x-shader/x-vertex">
      out vec3 bv;
      out vec2 bt;
      out vec3 bn;
      void main()
      {
        bt = uv;
        vec4 hv = modelMatrix * vec4( position, 1.0 );
        bv = hv.xyz/hv.w;
        bn = mat3(modelMatrix) * normal.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="csm_cm_shader_fs" type="x-shader/x-fragment">
      #define PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06

      in vec2 bt;
      in vec3 bv;
      in vec3 bn;

      uniform vec3 l;
      uniform vec3 eye;
      uniform float zNear;
      uniform float zFar;
      uniform float lightsize;
      uniform sampler2D tex0;
      uniform samplerCube cmmap[M +1];
      uniform mat4 lightmv;
      uniform float shadow_a;
      uniform float shadow_b;
      uniform float tex_size;

      vec4 getweights(float alpha, float k, float m)
      {
        vec4 weights = vec4(exp(-alpha*(k) *(k) / (m*m)),
        exp(-alpha*(k +1.0) *(k +1.0) / (m*m)),
        exp(-alpha*(k +2.0) *(k +2.0) / (m*m)),
        exp(-alpha*(k +3.0) *(k +3.0) / (m*m)));
        return weights;
      }

      float estimateFilterWidth(float lightsize, float currentDepth, float blockerDepth)
      {   // receiver depth
        float receiver = currentDepth;
        float FilterWidth = (receiver -blockerDepth) *lightsize / (2.0 * currentDepth*blockerDepth);
        return FilterWidth;
      }

      float estimatefwo(float lightsize, float distance, float smpos)
      {
        float aa, bb, cc;
        aa = lightsize / distance;
        bb = lightsize / smpos;
        aa = clamp(aa, 0.0, 1.0);
        bb = clamp(bb, 0.0, 1.0);

        //cc = aa*bb +sqrt( max((1.0 -aa*aa) *(1.0 -bb*bb),0.0));
        //return sqrt(max(1.0 / (cc*cc) -1.0,0.0));

        cc = aa*bb +sqrt((1.0 -aa*aa) *(1.0 -bb*bb));
        return sqrt(1.0 / (cc*cc) -1.0);
      }

      vec4 _f4mipmapCMMAP(samplerCube cmmap, vec3 uv, float fs)
      {
        vec4 result;
        uv = normalize(uv);
        float W0 = float(textureSize(cmmap, 0).x);
        float ml = log(W0*fs) / log(2.0);
        result = textureLod(cmmap, uv, ml);
        return result;
      }

      vec4 f4mipmapCMMAP(samplerCube cmmap, vec3 uv, float fs)
      {
        return _f4mipmapCMMAP(cmmap, uv, fs) *2.0-1.0;
      }

      float CSSM_CM_Z_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth
      ){
        vec4 tmp, sin_val_z, cos_val_z;
        float sum0, sum1;
        float depthvalue = f4mipmapCMMAP(cmmap[0], uv, filterwidth).x;
        sin_val_z = f4mipmapCMMAP(cmmap[4], uv, filterwidth);
        cos_val_z = f4mipmapCMMAP(cmmap[3], uv, filterwidth);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val_z*weights);
        sum1 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val_z*weights);
        return 0.5*depthvalue +2.0*(sum0 -sum1);
      }

      float CSSM_CM_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        float supress_flag
      ){
        vec4 tmp, sin_val, cos_val;
        float sum0, sum1;
        sin_val = f4mipmapCMMAP(cmmap[2], uv, filterwidth);
        cos_val = f4mipmapCMMAP(cmmap[1], uv, filterwidth);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val*weights);
        sum1 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val*weights);
        float rec = 0.5 +2.0*(sum0 -sum1);
        if (supress_flag == 1.0)
        rec = SCALEFACTOR*(rec -OFFSET);
        return clamp((1.0*rec), 0.0, 1.0);
      }

      float FindBlockDepth_CM(
        vec3 uv,
        float currentDepth,
        float distance,
        float lightsize,
        float zNear,
        float zFar
       ){
        float fs = estimatefwo(lightsize, distance, zNear);
        fs = clamp(fs, 0.0, 2.0);
        float blockedNum = 1.0 - CSSM_CM_Basis(uv, currentDepth, fs, 0.0);
        if( blockedNum>0.001 )
        {
          float Z_avg;
          Z_avg = CSSM_CM_Z_Basis(uv, currentDepth, fs) / blockedNum;
          return Z_avg*zFar;
        }
        else
        return distance+1.0;
      }

      float csm_cm_pcf_filter(
        vec3 uv,
        float currentDepth,
        float filterWidth
      ){
        float shadow = CSSM_CM_Basis(uv, currentDepth, filterWidth, 1.0);
        return shadow;
      }

      float CSM_CM_SoftShadow(
        vec3 uv,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        float shadow_a,
        float shadow_b
      ){
        float currentDepth = distance/zFar;
        float blockerdepth = FindBlockDepth_CM(uv, currentDepth, distance, lightsize, zNear, zFar);
        float shadow = 1.0;
        if( blockerdepth < distance  )
        {
          float FilterWidth = estimatefwo(lightsize, distance, blockerdepth);
          shadow = csm_cm_pcf_filter(uv, currentDepth, FilterWidth);
          float temp = shadow_b*(blockerdepth -distance);
          float power = 1.0 +shadow_a* exp(temp);
          shadow = pow(shadow, power);
        }
        return shadow;
      }

      void main()
      {

        gl_FragColor = vec4(1.0);
        float specular, diffuse, attenuation;
        float ld;
        vec3 ldir;
        {
          vec3 lpos, edir, ndir;
          ndir = normalize(bn);
          lpos = l-bv;
          ld = length(lpos);
          ldir = lpos/ld;
          edir = normalize( reflect( -(eye-bv), ndir) );  // normalize(  (eye-bv) - 2.0*dot( (eye-bv) ,ndir)* ndir);
          diffuse  = max(dot(ldir, ndir), 0.0);
          specular = pow(max(dot(ldir,edir),0.0), 8.0*mix( 4.0, 1.0, lightsize/.2 )   );
          attenuation = 1.5 / (1.0 + mix( .5, .75, lightsize/.2 ) * ld*ld );
        }

        float vb = CSM_CM_SoftShadow( -ldir*mat3(lightmv), ld, lightsize, zNear, zFar, shadow_a, shadow_b);
        // gl_FragColor.xyz = vec3(attenuation*( mix(diffuse,specular,.25) ) * vb);
        gl_FragColor.xyz = vec3(attenuation*diffuse* vb);
        gl_FragColor.w=1.0;
      }
    </script>

      <script id="csm_mldp_shader_vs" type="x-shader/x-vertex">
      out vec3 bv;
      out vec2 bt;
      out vec3 bn;
      void main()
      {
        bt = uv;
        vec4 hv = modelMatrix * vec4( position, 1.0 );
        bv = hv.xyz/hv.w;
        bn = mat3(modelMatrix) * normal.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="csm_mldp_shader_fs" type="x-shader/x-fragment">
      #define PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06
      #define MAX_LIGHT 16

 	    precision highp sampler2DArray;
	    precision mediump float;

      in vec2 bt;
      in vec3 bv;
      in vec3 bn;

      uniform vec3 eye;
      uniform float shadow_a;
      uniform float shadow_b;
      uniform float zNear;

      uniform vec3 l[MAX_LIGHT];
      uniform float mldp_zFar[MAX_LIGHT];
      uniform float lsize[MAX_LIGHT];
      uniform sampler2DArray mldpmap[MAX_LIGHT];
      uniform mat4 lightmv[MAX_LIGHT];
      uniform int num_dis_light;
      
      vec4 getweights(float alpha, float k, float m)
      {
        vec4 weights = vec4(exp(-alpha*(k) *(k) / (m*m)),
        exp(-alpha*(k +1.0) *(k +1.0) / (m*m)),
        exp(-alpha*(k +2.0) *(k +2.0) / (m*m)),
        exp(-alpha*(k +3.0) *(k +3.0) / (m*m)));
        return weights;
      }

      float estimateFilterWidth(float lightsize, float currentDepth, float blockerDepth)
      {
        // receiver depth
        float receiver = currentDepth;
        float FilterWidth = (receiver -blockerDepth) *lightsize / (2.0 * currentDepth*blockerDepth);
        return FilterWidth;
      }

      float estimatefwo(float lightsize, float distance, float smpos)
      {
        float aa, bb, cc;
        aa = lightsize / distance;
        bb = lightsize / smpos;

        aa = clamp(aa, 0.0, 1.0);
        bb = clamp(bb, 0.0, 1.0);
        cc = aa*bb +sqrt( max((1.0 -aa*aa) *(1.0 -bb*bb),0.0));

        return sqrt(1.0-cc*cc) / (1.0+cc);  // DP map filter size
      }

      float fscm2dp(float ws)
      {
        return ws;
        ws = clamp(ws, 0.0, 2.0);
        if (ws < 1.0)
        {
          ws /= sqrt(ws*ws+1.0) +1.0;
        }
        else
        {
          ws = 2.0 -ws;
          ws = sqrt(ws*ws+1.0) -ws;
        }
        return ws;
      }

      float ufunc( float zval, float fs )
      {
      vec2 p = vec2(sqrt(1.0-zval*zval), abs(zval));
      vec2 t = vec2(2.0*fs , 1.0-fs*fs)/(1.0+fs*fs);
      return max(p.x/(1.0+p.y)
      - (p.x*t.y-p.y*t.x)/(1.0+dot(p,t)), fs);
      }

      vec4 getTexVal(int idx, vec2 tc, int layer0, float ml)
      {
        if(idx==0)
         return textureLod(mldpmap[0], vec3(tc, layer0), ml);
        if(idx==1)
         return textureLod(mldpmap[1], vec3(tc, layer0), ml);
        if(idx==2)
         return textureLod(mldpmap[2], vec3(tc, layer0), ml);
        if(idx==3)
         return textureLod(mldpmap[3], vec3(tc, layer0), ml);
        if(idx==4)
         return textureLod(mldpmap[4], vec3(tc, layer0), ml);
        if(idx==5)
         return textureLod(mldpmap[5], vec3(tc, layer0), ml);
        if(idx==6)
         return textureLod(mldpmap[6], vec3(tc, layer0), ml);
        if(idx==7)
         return textureLod(mldpmap[7], vec3(tc, layer0), ml);
        if(idx==8)
         return textureLod(mldpmap[8], vec3(tc, layer0), ml);
        if(idx==9)
         return textureLod(mldpmap[9], vec3(tc, layer0), ml);
        if(idx==10)
         return textureLod(mldpmap[10], vec3(tc, layer0), ml);
        if(idx==11)
         return textureLod(mldpmap[11], vec3(tc, layer0), ml);
        if(idx==12)
         return textureLod(mldpmap[12], vec3(tc, layer0), ml);
        if(idx==13)
         return textureLod(mldpmap[13], vec3(tc, layer0), ml);
        if(idx==14)
         return textureLod(mldpmap[14], vec3(tc, layer0), ml);
        if(idx==15)
         return textureLod(mldpmap[15], vec3(tc, layer0), ml);
      }

      vec4 _f4mipmapMLDPMAP(int _lidx, int layer0, int layer1, vec3 uv, float fs)
      {
        fs = fscm2dp(fs);
        uv = normalize(uv);

        fs=.74*ufunc(uv.z, fs);

        float W0 = float(textureSize(mldpmap[0], 0).x);
        //float W0 = float(textureSize(mldpmap, 0).x);
        float ml = log(W0*fs) / log(2.0);
        vec2 tc = vec2(uv.x, uv.y) / (1.0 +uv.z);

        vec2 coordf = vec2(-tc.x, tc.y) *.5+.5;
        vec4 cfront= getTexVal(_lidx, coordf.xy, layer0, ml);//textureLod(mldp_map[i], vec3(coordf.xy, layer0), ml);
        tc = uv.xy / (1.0 -uv.z);
        vec2 coordb = tc*.5 +.5;
        vec4 cback = getTexVal(_lidx, coordb.xy, layer1, ml);//textureLod(mldp_map[i], vec3(coordb.xy, layer1), ml);

        // delete seams
        float resolution = 1.0 / fs;
        float sss = clamp((length(uv.xy)/(1.0 +abs(uv.z))-1.0)*resolution+1.0, 0.0, 1.0) * .5;
        if(uv.z < 0.0)
        sss = 1.0 -sss;
        return mix(cfront, cback, sss);
      }

      vec4 f4mipmapMLDPMAP(int lidx, int layer0, int layer1, vec3 uv, float fs)
      {
        return _f4mipmapMLDPMAP(lidx, layer0, layer1, uv, fs) *2.0-1.0;
      }

      float CSSM_Z_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        int lidx
      ){
        vec4 tmp, sin_val_z, cos_val_z;
        float sum0, sum1;
        float depthvalue = f4mipmapMLDPMAP(lidx, 0, 1, uv, filterwidth).x;
        sin_val_z = f4mipmapMLDPMAP(lidx, 5, 5+M, uv, filterwidth);
        cos_val_z = f4mipmapMLDPMAP(lidx, 4, 4+M, uv, filterwidth);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(sin(tmp*(currentDepth-fCSMBias)) / tmp, cos_val_z*weights);
        sum1 = dot(cos(tmp*(currentDepth-fCSMBias)) / tmp, sin_val_z*weights);
        return 0.5*depthvalue +2.0*(sum0 -sum1);
      }

      float CSSM_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        float supress_flag,
        int lidx
      ){
        vec4 tmp, sin_val, cos_val;
        float sum0, sum1;

        sin_val = f4mipmapMLDPMAP(lidx, 3, 3+M, uv, filterwidth);
        cos_val = f4mipmapMLDPMAP(lidx, 2, 2+M, uv, filterwidth);

        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));

        sum0 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val*weights);
        sum1 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val*weights);

        float rec = 0.5 +2.0*(sum0 - sum1);
        if(supress_flag == 1.0)
        rec = SCALEFACTOR*(rec -OFFSET);
        return clamp((1.0*rec), 0.0, 1.0);
      }

      float FindBlockDepth(
        vec3 uv,
        float currentDepth,
        float distance,
        float lightsize,
        int lidx,
        float zNear,
        float zFar
      ){
        float fs = estimatefwo(lightsize, distance, zNear);
        fs = clamp(fs, 0.0, 2.0);
        float blockedNum = 1.0 - CSSM_Basis(uv, currentDepth, fs, 0.0, lidx);
        if( blockedNum>0.001 )
        {
          float Z_avg;
          Z_avg = CSSM_Z_Basis(uv, currentDepth, fs, lidx) / blockedNum;
          return Z_avg*zFar;
        }
        else
          return distance+1.0;
      }

      float csm_pcf_filter(
        vec3 uv,
        float currentDepth,
        float filterWidth,
        int lidx
      ){
        float shadow = CSSM_Basis(uv, currentDepth, filterWidth, 1.0,lidx);
        return shadow;
      }

      float CSM_SoftShadow_ML(
        vec3 uv,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        int lidx,
        float shadow_a,
        float shadow_b
      ){
        float currentDepth = distance/zFar;
        float blockerdepth = FindBlockDepth(uv, currentDepth, distance, lightsize, lidx, zNear, zFar);
        float shadow = 1.0;
        if( blockerdepth < distance )
        {
          float FilterWidth = estimatefwo(lightsize, distance, blockerdepth);
          shadow = csm_pcf_filter(uv, currentDepth, FilterWidth, lidx);
          float temp = shadow_b*(blockerdepth - distance);
          float power = 1.0 +shadow_a* exp(temp);
          shadow = pow(shadow, power );
        }
        return shadow;
      }

      void main()
      {
        gl_FragColor = vec4(1.0); //texture(tex0, bt);

        float specular, diffuse, attenuation, vb, ld;
        vec3 uv, ldir;
        float acc= 0.0;

       for(int j=0; j<num_dis_light; j++)
        {
          vec3 lpos, edir, ndir;
          mat4 lmv;
          float lightsize;
          float zFar;
          lightsize = lsize[j];

          ndir = normalize(bn);
          lpos = l[j]-bv;
          ld = length(lpos);
          ldir = lpos/ld;
          edir = normalize( reflect( -(eye-bv), ndir) );  // normalize(  (eye-bv) - 2.0*dot( (eye-bv) ,ndir)* ndir);
          diffuse  = max(dot(ldir, ndir), 0.0);
          specular = pow(max(dot(ldir,edir),0.0), 8.0*mix( 4.0, 1.0, lightsize/.2 )   );
          attenuation = 1.5 / (1.0 + mix( .5, .75, lightsize/.2 ) * ld*ld );

          lmv = lightmv[j];
          zFar = mldp_zFar[j];
          uv = -ldir*mat3(lmv);

          vb = CSM_SoftShadow_ML(uv, ld, lightsize, zNear, zFar, j, shadow_a, shadow_b);
          acc += attenuation*diffuse* vb;
        } 
        gl_FragColor.xyz = vec3(acc)*1.0/float(num_dis_light);//0.4;
        gl_FragColor.w = 1.0;     
      }
    </script>


     <script id="csm_mlcm_shader_vs" type="x-shader/x-vertex">
      out vec3 bv;
      out vec2 bt;
      out vec3 bn;
      void main()
      {
        bt = uv;
        vec4 hv = modelMatrix * vec4( position, 1.0 );
        bv = hv.xyz/hv.w;
        bn = mat3(modelMatrix) * normal.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="csm_mlcm_shader_fs" type="x-shader/x-fragment">
      #define PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06
      #define N_LIGHT 3 

      in vec2 bt;
      in vec3 bv;
      in vec3 bn;

      uniform vec3 eye;
      uniform float zNear;
      uniform float shadow_a;
      uniform float shadow_b;
      uniform float tex_size;

      uniform vec3 l[N_LIGHT];
      uniform float mlcm_zFar[N_LIGHT];
      uniform float lsize[N_LIGHT];
      uniform samplerCube cmmap[N_LIGHT*(M+1)];
      uniform mat4 lightmv[N_LIGHT];
      uniform int ndis_light;

      vec4 getweights(float alpha, float k, float m)
      {
        vec4 weights = vec4(exp(-alpha*(k) *(k) / (m*m)),
        exp(-alpha*(k +1.0) *(k +1.0) / (m*m)),
        exp(-alpha*(k +2.0) *(k +2.0) / (m*m)),
        exp(-alpha*(k +3.0) *(k +3.0) / (m*m)));
        return weights;
      }

      float estimateFilterWidth(float lightsize, float currentDepth, float blockerDepth)
      {   // receiver depth
        float receiver = currentDepth;
        float FilterWidth = (receiver -blockerDepth) *lightsize / (2.0 * currentDepth*blockerDepth);
        return FilterWidth;
      }

      float estimatefwo(float lightsize, float distance, float smpos)
      {
        float aa, bb, cc;
        aa = lightsize / distance;
        bb = lightsize / smpos;
        aa = clamp(aa, 0.0, 1.0);
        bb = clamp(bb, 0.0, 1.0);

        cc = aa*bb +sqrt((1.0 -aa*aa) *(1.0 -bb*bb));
        return sqrt(1.0 / (cc*cc) -1.0);
      }

      vec4 getCMTexVal(int idx0, int basis_idx, vec3 uv, float ml)
      {
        if(basis_idx == 0)
        {
          if(idx0 == 0)
            return textureLod(cmmap[0], uv, ml);
          if(idx0 == 1)
            return textureLod(cmmap[5], uv, ml);
          if(idx0 == 2)
            return textureLod(cmmap[10], uv, ml);
        }
        if(basis_idx == 1)
        {
          if(idx0 == 0)
            return textureLod(cmmap[1], uv, ml);
          if(idx0 == 1)
            return textureLod(cmmap[6], uv, ml);
          if(idx0 == 2)
            return textureLod(cmmap[11], uv, ml);
        }   
        if(basis_idx == 2)
        {
          if(idx0 == 0)
            return textureLod(cmmap[2], uv, ml);
          if(idx0 == 1)
            return textureLod(cmmap[7], uv, ml);
          if(idx0 == 2)
            return textureLod(cmmap[12], uv, ml);
        }   
        if(basis_idx == 3)
        {
          if(idx0 == 0)
            return textureLod(cmmap[3], uv, ml);
          if(idx0 == 1)
            return textureLod(cmmap[8], uv, ml);
          if(idx0 == 2)
            return textureLod(cmmap[13], uv, ml);
        }   
        if(basis_idx == 4)
        {
          if(idx0 == 0)
            return textureLod(cmmap[4], uv, ml);
          if(idx0 == 1)
            return textureLod(cmmap[9], uv, ml);
          if(idx0 == 2)
            return textureLod(cmmap[14], uv, ml);
        }   
      }

      vec4 _f4mipmapCMMAP(vec3 uv, float fs, int idx0, int basis_idx)
      {
        vec4 result;
        uv = normalize(uv);
        float W0 = float(textureSize(cmmap[0], 0).x);
        float ml = log(W0*fs) / log(2.0);
        //result = textureLod(cmmap, uv, ml);
        result = getCMTexVal(idx0, basis_idx, uv, ml);
        return result;
      }

      vec4 f4mipmapCMMAP(vec3 uv, float fs, int idx0, int basis_idx)
      {
        return _f4mipmapCMMAP(uv, fs, idx0, basis_idx) *2.0-1.0;
      }

      float CSSM_CM_Z_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        int idx0
      ){
        vec4 tmp, sin_val_z, cos_val_z;
        float sum0, sum1;
        float depthvalue = f4mipmapCMMAP(uv, filterwidth, idx0, 0).x;
        sin_val_z = f4mipmapCMMAP(uv, filterwidth, idx0, 4);
        cos_val_z = f4mipmapCMMAP(uv, filterwidth, idx0, 3);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val_z*weights);
        sum1 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val_z*weights);
        return 0.5*depthvalue +2.0*(sum0 -sum1);
      }

      float CSSM_CM_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        float supress_flag,
        int idx0
      ){
        vec4 tmp, sin_val, cos_val;
        float sum0, sum1;
        sin_val = f4mipmapCMMAP(uv, filterwidth, idx0, 2);
        cos_val = f4mipmapCMMAP(uv, filterwidth, idx0, 1);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val*weights);
        sum1 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val*weights);
        float rec = 0.5 +2.0*(sum0 -sum1);
        if (supress_flag == 1.0)
        rec = SCALEFACTOR*(rec -OFFSET);
        return clamp((1.0*rec), 0.0, 1.0);
      }

      float FindBlockDepth_CM(
        vec3 uv,
        float currentDepth,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        int idx0
       ){
        float fs = estimatefwo(lightsize, distance, zNear);
        fs = clamp(fs, 0.0, 2.0);
        float blockedNum = 1.0 - CSSM_CM_Basis(uv, currentDepth, fs, 0.0, idx0);
        if( blockedNum>0.001 )
        {
          float Z_avg;
          Z_avg = CSSM_CM_Z_Basis(uv, currentDepth, fs, idx0) / blockedNum;
          return Z_avg*zFar;
        }
        else
        return distance+1.0;
      }

      float csm_cm_pcf_filter(
        vec3 uv,
        float currentDepth,
        float filterWidth,
        int idx0
      ){
        float shadow = CSSM_CM_Basis(uv, currentDepth, filterWidth, 1.0, idx0);
        return shadow;
      }

      float CSM_SoftShadow_MLCM(
        vec3 uv,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        float shadow_a,
        float shadow_b,
        int idx0
      ){
        float currentDepth = distance/zFar;
        float blockerdepth = FindBlockDepth_CM(uv, currentDepth, distance, lightsize, zNear, zFar, idx0);
        float shadow = 1.0;
        if( blockerdepth < distance  )
        {
          float FilterWidth = estimatefwo(lightsize, distance, blockerdepth);
          shadow = csm_cm_pcf_filter(uv, currentDepth, FilterWidth, idx0);
          float temp = shadow_b*(blockerdepth -distance);
          float power = 1.0 +shadow_a* exp(temp);
          shadow = pow(shadow, power);
        }
        return shadow;
      }

      void main()
      {

        gl_FragColor = vec4(1.0);
        float specular, diffuse, attenuation;
        float ld;
        vec3 ldir;
        vec3 uv;
        float lightsize, zFar, vb, acc = 0.0;
        mat3 lmv;

        for(int j=0; j<ndis_light; j++)
        {
          vec3 lpos, edir, ndir;
          ndir = normalize(bn);
          lpos = l[j]-bv;
          ld = length(lpos);
          ldir = lpos/ld;
          edir = normalize( reflect( -(eye-bv), ndir) ); 
          lmv = mat3(lightmv[j]);
          uv =  -ldir*lmv;
          lightsize = lsize[j];
          zFar = mlcm_zFar[j];

          diffuse  = max(dot(ldir, ndir), 0.0);
          specular = pow(max(dot(ldir,edir),0.0), 8.0*mix( 4.0, 1.0, lightsize/.2 )   );
          attenuation = 1.5 / (1.0 + mix( .5, .75, lightsize/.2 ) * ld*ld );

          vb = CSM_SoftShadow_MLCM( uv, ld, lightsize, zNear, zFar, shadow_a, shadow_b, j);
          acc += attenuation*diffuse* vb;
        }
        gl_FragColor.xyz = vec3(acc)*1.0/float(ndis_light);//0.4;
        gl_FragColor.w=1.0;
      }
    </script>

    <script id="csm_mlenvdp_shader_vs" type="x-shader/x-vertex">
      out vec3 bv;
      out vec2 bt;
      out vec3 bn;
      void main()
      {
        bt = uv;
        vec4 hv = modelMatrix * vec4( position, 1.0 );
        bv = hv.xyz/hv.w;
        bn = mat3(modelMatrix) * normal.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script id="csm_mlenvdp_shader_fs" type="x-shader/x-fragment">
      #define PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06
      #define MAX_LIGHT 8  // 16 will be too slow

      precision highp sampler2DArray;
      precision mediump float;

      in vec2 bt;
      in vec3 bv;
      in vec3 bn;

      uniform vec3 eye;
      uniform float shadow_a;
      uniform float shadow_b;
      uniform float zNear;

      uniform vec3 l[MAX_LIGHT];
      uniform float mlenvdp_zFar[MAX_LIGHT];
      uniform float lsize[MAX_LIGHT];
      uniform sampler2DArray mlenv_dpmap[MAX_LIGHT];
      uniform mat4 lightmv[MAX_LIGHT];
      uniform vec3 light_intensity[MAX_LIGHT];

      vec4 getweights(float alpha, float k, float m)
      {
        vec4 weights = vec4(exp(-alpha*(k) *(k) / (m*m)),
        exp(-alpha*(k +1.0) *(k +1.0) / (m*m)),
        exp(-alpha*(k +2.0) *(k +2.0) / (m*m)),
        exp(-alpha*(k +3.0) *(k +3.0) / (m*m)));
        return weights;
      }

      float estimateFilterWidth(float lightsize, float currentDepth, float blockerDepth)
      {
        // receiver depth
        float receiver = currentDepth;
        float FilterWidth = (receiver -blockerDepth) *lightsize / (2.0 * currentDepth*blockerDepth);
        return FilterWidth;
      }

      float estimatefwo(float lightsize, float distance, float smpos)
      {
        float aa, bb, cc;
        aa = lightsize / distance;
        bb = lightsize / smpos;

        aa = clamp(aa, 0.0, 1.0);
        bb = clamp(bb, 0.0, 1.0);
        cc = aa*bb +sqrt( max((1.0 -aa*aa) *(1.0 -bb*bb),0.0));

        return sqrt(1.0-cc*cc) / (1.0+cc);  // DP map filter size
      }

      float fscm2dp(float ws)
      {
        return ws;
        ws = clamp(ws, 0.0, 2.0);
        if (ws < 1.0)
        {
          ws /= sqrt(ws*ws+1.0) +1.0;
        }
        else
        {
          ws = 2.0 -ws;
          ws = sqrt(ws*ws+1.0) -ws;
        }
        return ws;
      }

      float ufunc( float zval, float fs )
      {
      vec2 p = vec2(sqrt(1.0-zval*zval), abs(zval));
      vec2 t = vec2(2.0*fs , 1.0-fs*fs)/(1.0+fs*fs);
      return max(p.x/(1.0+p.y)
      - (p.x*t.y-p.y*t.x)/(1.0+dot(p,t)), fs);
      }

      vec4 getTexVal(int idx, vec2 tc, int layer0, float ml)
      {
        if(idx==0)
         return textureLod(mlenv_dpmap[0], vec3(tc, layer0), ml);
        if(idx==1)
         return textureLod(mlenv_dpmap[1], vec3(tc, layer0), ml);
        if(idx==2)
         return textureLod(mlenv_dpmap[2], vec3(tc, layer0), ml);
        if(idx==3)
         return textureLod(mlenv_dpmap[3], vec3(tc, layer0), ml);
        if(idx==4)
         return textureLod(mlenv_dpmap[4], vec3(tc, layer0), ml);
        if(idx==5)
         return textureLod(mlenv_dpmap[5], vec3(tc, layer0), ml);
        if(idx==6)
         return textureLod(mlenv_dpmap[6], vec3(tc, layer0), ml);
        if(idx==7)
         return textureLod(mlenv_dpmap[7], vec3(tc, layer0), ml);
      }

      vec4 _f4mipmapMLENVDPMAP(int _lidx, int layer0, int layer1, vec3 uv, float fs)
      {
        fs = fscm2dp(fs);
        uv = normalize(uv);

        fs=.74*ufunc(uv.z, fs);

        float W0 = float(textureSize(mlenv_dpmap[0], 0).x);
        float ml = log(W0*fs) / log(2.0);
        vec2 tc = vec2(uv.x, uv.y) / (1.0 +uv.z);

        vec2 coordf = vec2(-tc.x, tc.y) *.5+.5;
        vec4 cfront= getTexVal(_lidx, coordf.xy, layer0, ml);
        tc = uv.xy / (1.0 -uv.z);
        vec2 coordb = tc*.5 +.5;
        vec4 cback = getTexVal(_lidx, coordb.xy, layer1, ml);

        // delete seams
        float resolution = 1.0 / fs;
        float sss = clamp((length(uv.xy)/(1.0 +abs(uv.z))-1.0)*resolution+1.0, 0.0, 1.0) * .5;
        if(uv.z < 0.0)
        sss = 1.0 -sss;
        return mix(cfront, cback, sss);
      }

      vec4 f4mipmapMLENVDPMAP(int lidx, int layer0, int layer1, vec3 uv, float fs)
      {
        return _f4mipmapMLENVDPMAP(lidx, layer0, layer1, uv, fs) *2.0-1.0;
      }

      float CSSM_Z_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        int lidx
      ){
        vec4 tmp, sin_val_z, cos_val_z;
        float sum0, sum1;
        float depthvalue = f4mipmapMLENVDPMAP(lidx, 0, 1, uv, filterwidth).x;
        sin_val_z = f4mipmapMLENVDPMAP(lidx, 5, 5+M, uv, filterwidth);
        cos_val_z = f4mipmapMLENVDPMAP(lidx, 4, 4+M, uv, filterwidth);
        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));
        sum0 = dot(sin(tmp*(currentDepth-fCSMBias)) / tmp, cos_val_z*weights);
        sum1 = dot(cos(tmp*(currentDepth-fCSMBias)) / tmp, sin_val_z*weights);
        return 0.5*depthvalue +2.0*(sum0 -sum1);
      }

      float CSSM_Basis(
        vec3 uv,
        float currentDepth,
        float filterwidth,
        float supress_flag,
        int lidx
      ){
        vec4 tmp, sin_val, cos_val;
        float sum0, sum1;

        sin_val = f4mipmapMLENVDPMAP(lidx, 3, 3+M, uv, filterwidth);
        cos_val = f4mipmapMLENVDPMAP(lidx, 2, 2+M, uv, filterwidth);

        tmp = PI*vec4(1.0, 3.0, 5.0, 7.0);
        vec4 weights = getweights(ALPHA, 1.0, float(M));

        sum0 = dot(cos(tmp*(currentDepth -fCSMBias)) / tmp, sin_val*weights);
        sum1 = dot(sin(tmp*(currentDepth -fCSMBias)) / tmp, cos_val*weights);

        float rec = 0.5 +2.0*(sum0 - sum1);
        if(supress_flag == 1.0)
        rec = SCALEFACTOR*(rec -OFFSET);
        return clamp((1.0*rec), 0.0, 1.0);
      }

      float FindBlockDepth(
        vec3 uv,
        float currentDepth,
        float distance,
        float lightsize,
        int lidx,
        float zNear,
        float zFar
      ){
        float fs = estimatefwo(lightsize, distance, zNear);
        fs = clamp(fs, 0.0, 2.0);
        float blockedNum = 1.0 - CSSM_Basis(uv, currentDepth, fs, 0.0, lidx);
        if( blockedNum>0.001 )
        {
          float Z_avg;
          Z_avg = CSSM_Z_Basis(uv, currentDepth, fs, lidx) / blockedNum;
          return Z_avg*zFar;
        }
        else
          return distance+1.0;
      }

      float csm_pcf_filter(
        vec3 uv,
        float currentDepth,
        float filterWidth,
        int lidx
      ){
        float shadow = CSSM_Basis(uv, currentDepth, filterWidth, 1.0,lidx);
        return shadow;
      }

      float CSM_SoftShadow_ML(
        vec3 uv,
        float distance,
        float lightsize,
        float zNear,
        float zFar,
        int lidx,
        float shadow_a,
        float shadow_b
      ){
        float currentDepth = distance/zFar;
        float blockerdepth = FindBlockDepth(uv, currentDepth, distance, lightsize, lidx, zNear, zFar);
        float shadow = 1.0;
        if( blockerdepth < distance )
        {
          float FilterWidth = estimatefwo(lightsize, distance, blockerdepth);
          shadow = csm_pcf_filter(uv, currentDepth, FilterWidth, lidx);
          float temp = shadow_b*(blockerdepth - distance);
          float power = 1.0 +shadow_a* exp(temp);
          shadow = pow(shadow, power );
        }
        return shadow;
      }

      void main()
      {
       gl_FragColor = vec4(1.0); //texture(tex0, bt);

       float specular, diffuse, attenuation, ld, vb;
       vec3 uv, ldir;
       vec3 acc= vec3(0.0);

       for(int j=0; j<MAX_LIGHT; j++)
        {
          vec3 lpos, edir, ndir;
          mat4 lmv;
          float lightsize;
          float zFar;
          lightsize = lsize[j];
          vec3 le = light_intensity[j];

          ndir = normalize(bn);
          lpos = l[j]-bv;
          ld = length(lpos);
          ldir = lpos/ld;
          edir = normalize( reflect( -(eye-bv), ndir) );  
          diffuse  = max(dot(ldir, ndir), 0.0);
          specular = pow(max(dot(ldir,edir),0.0), 8.0*mix( 4.0, 1.0, lightsize/.2 )   );
          attenuation = 1.5 / (1.0 + mix( .5, .75, lightsize/.2 ) * ld*ld );

          lmv = lightmv[j];
          zFar = mlenvdp_zFar[j];
          uv = -ldir*mat3(lmv);

          vb = CSM_SoftShadow_ML(uv, ld, lightsize, zNear, zFar, j, shadow_a, shadow_b);
          acc += le*attenuation*diffuse* vb;
        }
        gl_FragColor= vec4(acc*0.0002, 1.0);
      }
    </script>

    <script id="dp_shader_vs" type="x-shader/x-vertex">
      uniform mat4 mvp;
      uniform float zFar;
      out vec3 bc;
      void main()
      {
        // vec4 hp = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        // vec4 hp = projectionMatrix * viewMatrix * mix( modelMatrix0*position0, modelMatrix1*position1, weight );
        // vec4 v0 = mix( modelMatrix0*position0, modelMatrix1*position1, weight );

        vec4 v0 = modelMatrix * vec4( position, 1.0 );
        v0 = v0/v0.w;

        vec4 hp = mvp * v0;
        vec3 dp = normalize(hp.xyz);
        float  ll = length(hp.xyz);
        gl_Position.x =  dp.x / (dp.z+1.0);
        gl_Position.y = -dp.y / (dp.z+1.0);
        float focal_length = 0.04;
        float dist_focus_to_parabolid =  focal_length * 2.0*ll / ( ll+ hp.z) ;
        float dist_vertex_to_parabolid = ll - dist_focus_to_parabolid;
        gl_Position.z = dist_vertex_to_parabolid + focal_length  - 1.0 ;
        gl_Position.w = 1.0;

        bc = v0.xyz;
      }
    </script>

    <script id="dp_shader_fs" type="x-shader/x-fragment">
      in vec3 bc;
      uniform float zFar;
      uniform vec3 l;
      void main()
      {
        float depth = length(bc-l) / zFar;
        gl_FragColor = vec4(depth, 1.0, 1.0, 1.0);
        gl_FragColor = (gl_FragColor+1.0) /2.0;
        // gl_FragColor.xyz = bc;
      }
    </script>

    <script id="cm_shader_vs" type="x-shader/x-vertex">
      uniform mat4 mvp;
      uniform float zFar;
      out vec3 bc;
      void main()
      {
        vec4 v0 = modelMatrix * vec4( position, 1.0 );
        v0 = v0/v0.w;
        gl_Position = mvp * v0;
        bc = v0.xyz;
      }
    </script>

    <script id="cm_shader_fs" type="x-shader/x-fragment">
      in vec3 bc;
      uniform float zFar;
      uniform vec3 l;
      void main()
      {
        float depth = length(bc-l) / zFar;
        gl_FragColor = vec4(depth, 1.0, 1.0, 1.0);
        gl_FragColor = (gl_FragColor+1.0) /2.0;
        // gl_FragColor.xyz = bc;
      }
    </script>

    <!--multiple light  gen dp shadow map shader-->
    <script id="mldp_shader_vs" type="x-shader/x-vertex">
      uniform mat4 mvp;
      uniform float zFar;
      out vec3 bc;
      void main()
      {
        vec4 v0 = modelMatrix * vec4( position, 1.0 );
        v0 = v0/v0.w;

        vec4 hp = mvp * v0;
        vec3 dp = normalize(hp.xyz);
        float  ll = length(hp.xyz);
        gl_Position.x =  dp.x / (dp.z+1.0);
        gl_Position.y = -dp.y / (dp.z+1.0);
        float focal_length = 0.04;
        float dist_focus_to_parabolid =  focal_length * 2.0*ll / ( ll+ hp.z) ;
        float dist_vertex_to_parabolid = ll - dist_focus_to_parabolid;
        gl_Position.z = dist_vertex_to_parabolid + focal_length  - 1.0 ;
        gl_Position.w = 1.0;

        bc = v0.xyz;
      }
    </script>

    <script id="mldp_shader_fs" type="x-shader/x-fragment">
      in vec3 bc;
      uniform float zFar;
      uniform vec3 l;
      void main()
      {
        float depth = length(bc-l) / zFar;
        gl_FragColor = vec4(depth, 1.0, 1.0, 1.0);
        gl_FragColor = (gl_FragColor+1.0) /2.0;
      }
    </script>
    <!--multiple light  gen cm shadow map shader-->
    <script id="mlcm_shader_vs" type="x-shader/x-vertex">
      uniform mat4 mvp;
      uniform float zFar;
      out vec3 bc;
      void main()
      {
        vec4 v0 = modelMatrix * vec4( position, 1.0 );
        v0 = v0/v0.w;
        gl_Position = mvp * v0;
        bc = v0.xyz;
      }
    </script>

    <script id="mlcm_shader_fs" type="x-shader/x-fragment">
      in vec3 bc;
      uniform float zFar;
      uniform vec3 l;
      void main()
      {
        float depth = length(bc-l) / zFar;
        gl_FragColor = vec4(depth, 1.0, 1.0, 1.0);
        gl_FragColor = (gl_FragColor+1.0) /2.0;
      }
    </script>


    <script>
      var my_vertex_func = `
      vec4 func0()
      {
        return vec4(0,0,0,0);
      }
      `;
      var my_vertex_output = `
        // hihi
      `;
      var my_fragment_func = `
      vec4 func0()
      {
        return vec4(0,1,0,1);
      }
      `;
      var my_fragment_output = `
        //gl_FragColor = func0() * gl_FragColor;
        gl_FragColor = gl_FragColor;
      `;
    </script>

    <!--for handle gltf model shader-->
    <script>
      var csm_mldp_vertex_input = `
      vec4 func0()
      {
        return vec4(0,0,0,0);
      }
      `;
      var csm_mldp_vertex_output = `
        // hihi
      `;
      var csm_mldp_fragment_input = `
      #define J_PI 3.14159265358979
      #define M 4
      #define fCSMBias 0.068
      #define OFFSET 0.02
      #define SCALEFACTOR 1.11
      #define ALPHA 0.06
      #define N_LIGHT 3 
      #define MAX_LIGHT 16
      `;
      var csm_mldp_fragment_output = `
        gl_FragColor = gl_FragColor;
      `;

      var csm_mldp_frag_input=`
      #include <common>
      uniform vec3 testp;
      uniform vec3 lpos[3];
      varying vec3 testl;
      `
      ;


    </script>

    <script>
      var canvas = document.createElement('canvas');
      gl = canvas.getContext('webgl2');

    </script>

    <script src="bezier_length.js"></script>
    <!--<script src="readEnvMap.js"></script>-->

    <script src="m4.js"></script>
    <script src="g_vector.js"></script>
    <script src="g_shader.js"></script>
    <script src="shader_js/genbasis_shader.js"></script>
    <script src="shader_js/genbasis_shader_cm.js"></script>
    <script src="shader_js/drawtex_shader.js"></script>
    <script src="shader_js/drawcmtex_shader.js"></script>

    <!--multiple light basis shader-->
    <script src="shader_js/genbasis_shader_mldp.js"></script>
    <script src="shader_js/genbasis_shader_mldps.js"></script>
    <script src="shader_js/drawmldptex_shader.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm"
          }
      }
    </script>
    <script type="module" src="./index.js"></script>

  </body>
</html>